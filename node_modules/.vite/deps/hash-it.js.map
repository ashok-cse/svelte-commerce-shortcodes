{
  "version": 3,
  "sources": ["../../hash-it/src/hash.ts", "../../hash-it/src/constants.ts", "../../hash-it/src/arrayBuffer.ts", "../../hash-it/src/stringify.ts", "../../hash-it/src/index.ts", "dep:hash-it"],
  "sourcesContent": ["/**\n * based on string passed, get the integer hash value\n * through bitwise operation (based on spinoff of dbj2\n * with enhancements for reduced collisions)\n *\n * @param string the string to get the hash value for\n * @returns the hash value\n */\nfunction getUniqueIntegerFromString(string: string) {\n  let index = string.length;\n  let hashA = 5381;\n  let hashB = 52711;\n  let charCode;\n\n  while (index--) {\n    charCode = string.charCodeAt(index);\n\n    hashA = (hashA * 33) ^ charCode;\n    hashB = (hashB * 33) ^ charCode;\n  }\n\n  return (hashA >>> 0) * 4096 + (hashB >>> 0);\n}\n\nexport default getUniqueIntegerFromString;\n", "type ElementOf<T> = T extends (infer E)[]\n  ? E\n  : T extends readonly (infer E)[]\n  ? E\n  : never;\n\ntype MappedFlag<Type extends readonly any[]> = {\n  [Key in ElementOf<Type>]: true;\n};\n\ntype MappedClass<Type extends readonly any[]> = {\n  [Key in ElementOf<Type>]: `[object ${Key}]`;\n};\n\ntype MappedReverseClass<Type extends readonly any[]> = {\n  [Key in ElementOf<Type> as `[object ${Key}]`]: Key;\n};\n\nconst getClassTypes = <\n  Classes extends readonly any[],\n  Reversed extends boolean,\n>(\n  classes: Classes,\n  reversed: Reversed,\n): Reversed extends true ? MappedReverseClass<Classes> : MappedClass<Classes> =>\n  classes.reduce((map, className: Classes[number]) => {\n    const toStringClassName = `[object ${className}]`;\n\n    if (reversed) {\n      map[toStringClassName] = className;\n    } else {\n      map[className] = toStringClassName;\n    }\n\n    return map;\n  }, {});\n\nconst getFlags = <Flags extends readonly any[]>(\n  flags: Flags,\n): MappedFlag<Flags> =>\n  flags.reduce((flag, item: Flags[number]) => {\n    flag[item] = true;\n\n    return flag;\n  }, {});\n\nconst OBJECT_CLASSES = [\n  // self tags\n  'Array',\n  'Arguments',\n\n  'Object',\n\n  // toString tags\n  'RegExp',\n  'Symbol',\n\n  // iterable tags\n  'Map',\n  'Set',\n\n  'Date',\n\n  'Error',\n\n  'Event',\n\n  // bailout tags\n  'Generator',\n  'Promise',\n  'WeakMap',\n  'WeakSet',\n\n  'DocumentFragment',\n\n  // typed array tags\n  'Float32Array',\n  'Float64Array',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n\n  'ArrayBuffer',\n\n  'DataView',\n\n  'DocumentFragment',\n\n  'Window',\n\n  // primitive classes, e.g. new String()\n  'String',\n  'Number',\n  'Boolean',\n  'Function',\n  'Undefined',\n  'GeneratorFunction',\n  'BigInt',\n  'Null',\n] as const;\n\nexport const OBJECT_CLASS_TYPE = getClassTypes(OBJECT_CLASSES, false);\nexport const OBJECT_CLASS = getClassTypes(OBJECT_CLASSES, true);\n\nexport const BAILOUT_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Generator,\n  OBJECT_CLASS_TYPE.Promise,\n  OBJECT_CLASS_TYPE.WeakMap,\n  OBJECT_CLASS_TYPE.WeakSet,\n]);\n\nexport const ITERABLE_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Map,\n  OBJECT_CLASS_TYPE.Set,\n]);\n\nexport const NORMALIZED_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Date,\n  OBJECT_CLASS_TYPE.RegExp,\n]);\n\nexport const PRIMITIVE_TAGS = getFlags([\n  'bigint',\n  'boolean',\n  'function',\n  'number',\n  'string',\n  'undefined',\n]);\n\nexport const SELF_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Arguments,\n  OBJECT_CLASS_TYPE.Array,\n]);\n\nexport const TO_STRING_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.RegExp,\n  OBJECT_CLASS_TYPE.Symbol,\n]);\n\nexport const TYPED_ARRAY_TAGS = getFlags([\n  OBJECT_CLASS_TYPE.Float32Array,\n  OBJECT_CLASS_TYPE.Float64Array,\n  OBJECT_CLASS_TYPE.Int8Array,\n  OBJECT_CLASS_TYPE.Int16Array,\n  OBJECT_CLASS_TYPE.Int32Array,\n  OBJECT_CLASS_TYPE.Uint8Array,\n  OBJECT_CLASS_TYPE.Uint8ClampedArray,\n  OBJECT_CLASS_TYPE.Uint16Array,\n  OBJECT_CLASS_TYPE.Uint32Array,\n]);\n", "const HAS_BUFFER_FROM_SUPPORT =\n  typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';\nconst HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';\n\n/**\n * get the string value of the buffer passed based on a Buffer\n *\n * @param buffer the array buffer to convert\n * @returns the stringified buffer\n */\nexport function getStringifiedArrayBufferFallback(\n  buffer: ArrayBufferLike,\n): string {\n  return String.fromCharCode.apply(\n    null,\n    new Uint16Array(buffer) as unknown as number[],\n  );\n}\n\n/**\n * get the string value of the buffer passed based on a Uint16Array\n *\n * @param buffer the array buffer to convert\n * @returns the stringified buffer\n */\nexport function getStringifiedArrayBufferModern(\n  buffer: ArrayBufferLike,\n): string {\n  return Buffer.from(buffer).toString('utf8');\n}\n\n/**\n * return a placeholder when no arraybuffer support exists\n *\n * @returns the placeholder\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function getStringifiedArrayBufferNoSupport(buffer: ArrayBufferLike) {\n  return '';\n}\n\n/**\n * @function getStringifiedArrayBuffer\n *\n * @description\n * get the string value of the buffer passed\n *\n * @param {ArrayBuffer} buffer the array buffer to convert\n * @returns {string} the stringified buffer\n */\nexport const getStringifiedArrayBuffer = (() => {\n  if (HAS_BUFFER_FROM_SUPPORT) {\n    return getStringifiedArrayBufferModern;\n  }\n\n  if (HAS_UINT16ARRAY_SUPPORT) {\n    return getStringifiedArrayBufferFallback;\n  }\n\n  return getStringifiedArrayBufferNoSupport;\n})();\n", "import {\n  BAILOUT_TAGS,\n  ITERABLE_TAGS,\n  NORMALIZED_TAGS,\n  OBJECT_CLASS,\n  OBJECT_CLASS_TYPE,\n  PRIMITIVE_TAGS,\n  SELF_TAGS,\n  TO_STRING_TAGS,\n  TYPED_ARRAY_TAGS,\n} from './constants';\nimport { getStringifiedArrayBuffer } from './arrayBuffer';\n\ntype ObjectClass = keyof typeof OBJECT_CLASS;\n\nconst XML_ELEMENT_REGEXP = /\\[object ([HTML|SVG](.*)Element)\\]/;\n\nconst toString = Object.prototype.toString;\nconst keys = Object.keys;\n\n/**\n * get the event object sorted by its properties\n *\n * @param event the event to sort\n * @returns the event object with all properties sorted\n */\nfunction getSortedEvent(event: Event) {\n  return {\n    bubbles: event.bubbles,\n    cancelBubble: event.cancelBubble,\n    cancelable: event.cancelable,\n    composed: event.composed,\n    currentTarget: event.currentTarget,\n    defaultPrevented: event.defaultPrevented,\n    eventPhase: event.eventPhase,\n    isTrusted: event.isTrusted,\n    returnValue: event.returnValue,\n    target: event.target,\n    type: event.type,\n  };\n}\n\n/**\n * get the sort result based on the two values to compare\n *\n * @param first the first value to compare\n * @param second the second value to compare\n * @returns should the value be sorted\n */\nfunction shouldSort(first: string, second: string) {\n  return first > second;\n}\n\n/**\n * get the sort result based on the two pairs to compare\n *\n * @param firstPair the first pair to compare\n * @param secondPair the second pair to compare\n * @returns should the value be sorted\n */\nfunction shouldSortPair(\n  firstPair: [string, string],\n  secondPair: [string, string],\n) {\n  return firstPair[0] > secondPair[0];\n}\n\n/**\n * sort the array based on the fn passed\n *\n * @param array the array to sort\n * @param fn the sorting function\n * @returns the sorted array\n */\nfunction sort(array: any[], fn: (item: any, comparisonItem: any) => boolean) {\n  let subIndex;\n  let value;\n\n  for (let index = 0; index < array.length; ++index) {\n    value = array[index];\n\n    for (\n      subIndex = index - 1;\n      ~subIndex && fn(array[subIndex], value);\n      --subIndex\n    ) {\n      array[subIndex + 1] = array[subIndex];\n    }\n\n    array[subIndex + 1] = value;\n  }\n\n  return array;\n}\n\n/**\n * get the pairs in the map for stringification\n *\n * @param map the map to get the pairs for\n * @returns the sorted, stringified map\n */\nfunction getSortedMap(map: Map<any, any>, cache: any[], keys: string[]) {\n  const entries: string[] = [];\n\n  map.forEach((value: any, key: any) => {\n    entries.push([\n      stringify(key, cache, keys),\n      stringify(value, cache, keys),\n    ] as unknown as string);\n  });\n\n  sort(entries, shouldSortPair);\n\n  for (let index = 0, entry; index < entries.length; ++index) {\n    entry = entries[index];\n    entries[index] = `[${entry[0]},${entry[1]}]`;\n  }\n\n  return `Map|[${entries.join(',')}]`;\n}\n\n/**\n * get the values in the set for stringification\n *\n * @param set the set to get the values for\n * @returns the sorted, stringified set\n */\nfunction getSortedSet(set: Set<any>, cache: any[], keys: string[]) {\n  const entries: string[] = [];\n\n  set.forEach((value: any) => {\n    entries.push(stringify(value, cache, keys));\n  });\n\n  sort(entries, shouldSort);\n\n  return `Set|[${entries.join(',')}]`;\n}\n\n/**\n * get the object with the keys sorted\n *\n * @param object the object to sort\n * @returns the sorted object\n */\nfunction getSortedObject<UnsortedObject>(object: UnsortedObject) {\n  const objectKeys = sort(keys(object), shouldSort);\n  const newObject = {} as UnsortedObject;\n\n  let key: keyof UnsortedObject;\n\n  for (let index = 0; index < objectKeys.length; ++index) {\n    key = objectKeys[index];\n\n    newObject[key] = object[key];\n  }\n\n  return newObject;\n}\n\n/**\n * build a string based on all the fragment's children\n *\n * @param fragment the fragment to stringify\n * @returns the stringified fragment\n */\nfunction getStringifiedDocumentFragment(fragment: DocumentFragment) {\n  const children = fragment.children;\n  const innerHTML: string[] = [];\n\n  for (let index = 0; index < children.length; ++index) {\n    innerHTML.push(children[index].outerHTML);\n  }\n\n  return innerHTML.join(',');\n}\n\n/**\n * get the index after that of the value match in the array (faster than\n * native indexOf) to determine the cutoff index for the `splice()` call.\n *\n * @param array the array to get the index of the value at\n * @param value the value to match\n * @returns the index after the value match in the array\n */\nfunction getCutoffIndex(array: any[], value: any) {\n  for (let index = 0; index < array.length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * get the value normalized for stringification\n *\n * @param value the value to normalize\n * @param sortedCache the cache of sorted objects\n * @param passedTag the previously-calculated tag\n * @returns the normalized value\n */\nfunction getNormalizedValue(\n  value: any,\n  cache?: any[],\n  keys?: string[],\n  passedTag?: ObjectClass,\n) {\n  if (!passedTag) {\n    const type = typeof value;\n\n    if (PRIMITIVE_TAGS[type as keyof typeof PRIMITIVE_TAGS]) {\n      return `${type}|${value}`;\n    }\n\n    if (value === null) {\n      return `${value}|${value}`;\n    }\n  }\n\n  const tag = passedTag || (toString.call(value) as ObjectClass);\n\n  if (SELF_TAGS[tag as keyof typeof SELF_TAGS]) {\n    return value;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Object) {\n    return getSortedObject(value);\n  }\n\n  if (TO_STRING_TAGS[tag as keyof typeof TO_STRING_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|${value.toString()}`;\n  }\n\n  if (ITERABLE_TAGS[tag as keyof typeof ITERABLE_TAGS]) {\n    return value instanceof Map\n      ? getSortedMap(value, cache as any[], keys as string[])\n      : getSortedSet(value, cache as any, keys as string[]);\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Date) {\n    return `${OBJECT_CLASS[tag]}|${value.getTime()}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Error) {\n    return `${OBJECT_CLASS[tag]}|${value.stack}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.Event) {\n    return getSortedEvent(value);\n  }\n\n  if (BAILOUT_TAGS[tag as keyof typeof BAILOUT_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|NOT_ENUMERABLE`;\n  }\n\n  if (XML_ELEMENT_REGEXP.test(tag)) {\n    return `${tag.slice(8, -1)}|${value.outerHTML}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.DocumentFragment) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedDocumentFragment(value)}`;\n  }\n\n  if (TYPED_ARRAY_TAGS[tag as keyof typeof TYPED_ARRAY_TAGS]) {\n    return `${OBJECT_CLASS[tag]}|${value.join(',')}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.ArrayBuffer) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedArrayBuffer(value)}`;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE.DataView) {\n    return `${OBJECT_CLASS[tag]}|${getStringifiedArrayBuffer(value.buffer)}`;\n  }\n\n  return value;\n}\n\n/**\n * create the replacer function used for stringification\n *\n * @param sortedCache the cache to use for sorting objects\n * @returns function getting the normalized value\n */\nfunction createReplacer(cache: any[] = [], keys: string[] = []) {\n  return function (this: any, key: string, value: any) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoffIndex(cache, this);\n\n        if (thisCutoff === 0) {\n          cache.push(this);\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys.push(key);\n\n        const valueCutoff = getCutoffIndex(cache, value);\n\n        if (valueCutoff !== 0) {\n          return `[~${keys.slice(0, valueCutoff).join('.') || '.'}]`;\n        }\n\n        cache.push(value);\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    if (key && this[key] instanceof Date) {\n      return getNormalizedValue(this[key], cache, keys, OBJECT_CLASS_TYPE.Date);\n    }\n\n    return getNormalizedValue(value, cache, keys);\n  };\n}\n\n/**\n * stringify the value based on the options passed\n *\n * @param value the value to stringify\n * @returns the stringified value\n */\nfunction stringify(value: any, cache?: any[], keys?: string[]): string {\n  if (!value || typeof value !== 'object') {\n    return getNormalizedValue(value, cache, keys);\n  }\n\n  const tag = toString.call(value) as ObjectClass;\n\n  if (NORMALIZED_TAGS[tag as keyof typeof NORMALIZED_TAGS]) {\n    return getNormalizedValue(value, cache, keys, tag);\n  }\n\n  return JSON.stringify(value, createReplacer(cache, keys));\n}\n\nexport default stringify;\n", "import getUniqueIntegerFromString from './hash';\nimport stringify from './stringify';\n\n/**\n * hash the value passed to a unique, consistent hash value\n *\n * @param value the value to hash\n * @returns the object hash\n */\nfunction hash(value: any) {\n  return getUniqueIntegerFromString(stringify(value));\n}\n\nfunction is(value: any, otherValue: any) {\n  return hash(value) === hash(otherValue);\n}\n\nfunction isAll(value: any, ...otherValues: any[]) {\n  for (let index = 0; index < otherValues.length; ++index) {\n    if (!is(value, otherValues[index])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isAny(value: any, ...otherValues: any[]) {\n  for (let index = 0; index < otherValues.length; ++index) {\n    if (is(value, otherValues[index])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isNot(value: any, otherValue: any) {\n  return hash(value) !== hash(otherValue);\n}\n\nis.all = isAll;\nis.any = isAny;\nis.not = isNot;\n\nhash.is = is;\n\nexport default hash;\n", "import d from \"./node_modules/hash-it/dist/hash-it.esm.js\";export default d;"],
  "mappings": ";;;AAQA,SAASA,2BAA2BC,QAAgB;AAClD,MAAIC,QAAQD,OAAOE;AACnB,MAAIC,QAAQ;AACZ,MAAIC,QAAQ;AACZ,MAAIC;AAEJ,SAAOJ,SAAS;AACdI,eAAWL,OAAOM,WAAWL,KAAlB;AAEXE,YAASA,QAAQ,KAAME;AACvBD,YAASA,QAAQ,KAAMC;EACxB;AAED,UAAQF,UAAU,KAAK,QAAQC,UAAU;AAC1C;ACJD,IAAMG,gBAAgB,SAAhBA,eAIJC,SACAC,UALoB;AAAA,SAOpBD,QAAQE,OAAO,SAACC,KAAKC,WAA+B;AAClD,QAAMC,oBAAiB,aAAcD,YAAd;AAEvB,QAAIH,UAAU;AACZE,UAAIE,qBAAqBD;IAC1B,OAAM;AACLD,UAAIC,aAAaC;IAClB;AAED,WAAOF;EACR,GAAE,CAAA,CAVH;AAPoB;AAmBtB,IAAMG,WAAW,SAAXA,UACJC,OADe;AAAA,SAGfA,MAAML,OAAO,SAACM,MAAMC,MAAwB;AAC1CD,SAAKC,QAAQ;AAEb,WAAOD;EACR,GAAE,CAAA,CAJH;AAHe;AASjB,IAAME,iBAAiB;EAErB;EACA;EAEA;EAGA;EACA;EAGA;EACA;EAEA;EAEA;EAEA;EAGA;EACA;EACA;EACA;EAEA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EAEA;EAEA;EAEA;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AAxDqB;AA2DhB,IAAMC,oBAAoBZ,cAAcW,gBAAgB,KAAjB;AACvC,IAAME,eAAeb,cAAcW,gBAAgB,IAAjB;AAElC,IAAMG,eAAeP,SAAS,CACnCK,kBAAkBG,WAClBH,kBAAkBI,SAClBJ,kBAAkBK,SAClBL,kBAAkBM,OAJiB,CAAD;AAO7B,IAAMC,gBAAgBZ,SAAS,CACpCK,kBAAkBQ,KAClBR,kBAAkBS,GAFkB,CAAD;AAK9B,IAAMC,kBAAkBf,SAAS,CACtCK,kBAAkBW,MAClBX,kBAAkBY,MAFoB,CAAD;AAKhC,IAAMC,iBAAiBlB,SAAS,CACrC,UACA,WACA,YACA,UACA,UACA,WANqC,CAAD;AAS/B,IAAMmB,YAAYnB,SAAS,CAChCK,kBAAkBe,WAClBf,kBAAkBgB,KAFc,CAAD;AAK1B,IAAMC,iBAAiBtB,SAAS,CACrCK,kBAAkBY,QAClBZ,kBAAkBkB,MAFmB,CAAD;AAK/B,IAAMC,mBAAmBxB,SAAS,CACvCK,kBAAkBoB,cAClBpB,kBAAkBqB,cAClBrB,kBAAkBsB,WAClBtB,kBAAkBuB,YAClBvB,kBAAkBwB,YAClBxB,kBAAkByB,YAClBzB,kBAAkB0B,mBAClB1B,kBAAkB2B,aAClB3B,kBAAkB4B,WATqB,CAAD;AChJxC,IAAMC,0BACJ,OAAOC,WAAW,eAAe,OAAOA,OAAOC,SAAS;AAC1D,IAAMC,0BAA0B,OAAOL,gBAAgB;AAQhD,SAASM,kCACdC,QACQ;AACR,SAAOC,OAAOC,aAAaC,MACzB,MACA,IAAIV,YAAYO,MAAhB,CAFK;AAIR;AAQM,SAASI,gCACdJ,QACQ;AACR,SAAOJ,OAAOC,KAAKG,MAAZ,EAAoBK,SAAS,MAA7B;AACR;AAQM,SAASC,mCAAmCN,QAAyB;AAC1E,SAAO;AACR;AAWM,IAAMO,4BAA6B,WAAM;AAC9C,MAAIZ,yBAAyB;AAC3B,WAAOS;EACR;AAED,MAAIN,yBAAyB;AAC3B,WAAOC;EACR;AAED,SAAOO;AACR,EAVwC;ACnCzC,IAAME,qBAAqB;AAE3B,IAAMH,WAAWI,OAAOC,UAAUL;AAClC,IAAMM,OAAOF,OAAOE;AAQpB,SAASC,eAAeC,OAAc;AACpC,SAAO;IACLC,SAASD,MAAMC;IACfC,cAAcF,MAAME;IACpBC,YAAYH,MAAMG;IAClBC,UAAUJ,MAAMI;IAChBC,eAAeL,MAAMK;IACrBC,kBAAkBN,MAAMM;IACxBC,YAAYP,MAAMO;IAClBC,WAAWR,MAAMQ;IACjBC,aAAaT,MAAMS;IACnBC,QAAQV,MAAMU;IACdC,MAAMX,MAAMW;EAXP;AAaR;AASD,SAASC,WAAWC,OAAeC,QAAgB;AACjD,SAAOD,QAAQC;AAChB;AASD,SAASC,eACPC,WACAC,YACA;AACA,SAAOD,UAAU,KAAKC,WAAW;AAClC;AASD,SAASC,KAAKC,OAAcC,IAAiD;AAC3E,MAAIC;AACJ,MAAIC;AAEJ,WAASvF,QAAQ,GAAGA,QAAQoF,MAAMnF,QAAQ,EAAED,OAAO;AACjDuF,YAAQH,MAAMpF;AAEd,SACEsF,WAAWtF,QAAQ,GACnB,CAACsF,YAAYD,GAAGD,MAAME,WAAWC,KAAlB,GACf,EAAED,UACF;AACAF,YAAME,WAAW,KAAKF,MAAME;IAC7B;AAEDF,UAAME,WAAW,KAAKC;EACvB;AAED,SAAOH;AACR;AAQD,SAASI,aAAa9E,KAAoB+E,OAAc1B,OAAgB;AACtE,MAAM2B,UAAoB,CAAA;AAE1BhF,MAAIiF,QAAQ,SAACJ,OAAYK,KAAa;AACpCF,YAAQG,KAAK,CACXC,UAAUF,KAAKH,OAAO1B,KAAb,GACT+B,UAAUP,OAAOE,OAAO1B,KAAf,CAFE,CAAb;EAID,CALD;AAOAoB,OAAKO,SAASV,cAAV;AAEJ,WAAShF,QAAQ,GAAG+F,OAAO/F,QAAQ0F,QAAQzF,QAAQ,EAAED,OAAO;AAC1D+F,YAAQL,QAAQ1F;AAChB0F,YAAQ1F,SAAR,MAAqB+F,MAAM,KAA3B,MAAiCA,MAAM,KAAvC;EACD;AAED,SAAA,UAAeL,QAAQM,KAAK,GAAb,IAAf;AACD;AAQD,SAASC,aAAaC,KAAeT,OAAc1B,OAAgB;AACjE,MAAM2B,UAAoB,CAAA;AAE1BQ,MAAIP,QAAQ,SAACJ,OAAe;AAC1BG,YAAQG,KAAKC,UAAUP,OAAOE,OAAO1B,KAAf,CAAtB;EACD,CAFD;AAIAoB,OAAKO,SAASb,UAAV;AAEJ,SAAA,UAAea,QAAQM,KAAK,GAAb,IAAf;AACD;AAQD,SAASG,gBAAgCC,QAAwB;AAC/D,MAAMC,aAAalB,KAAKpB,KAAKqC,MAAD,GAAUvB,UAAf;AACvB,MAAMyB,YAAY,CAAA;AAElB,MAAIV;AAEJ,WAAS5F,QAAQ,GAAGA,QAAQqG,WAAWpG,QAAQ,EAAED,OAAO;AACtD4F,UAAMS,WAAWrG;AAEjBsG,cAAUV,OAAOQ,OAAOR;EACzB;AAED,SAAOU;AACR;AAQD,SAASC,+BAA+BC,UAA4B;AAClE,MAAMC,WAAWD,SAASC;AAC1B,MAAMC,YAAsB,CAAA;AAE5B,WAAS1G,QAAQ,GAAGA,QAAQyG,SAASxG,QAAQ,EAAED,OAAO;AACpD0G,cAAUb,KAAKY,SAASzG,OAAO2G,SAA/B;EACD;AAED,SAAOD,UAAUV,KAAK,GAAf;AACR;AAUD,SAASY,eAAexB,OAAcG,OAAY;AAChD,WAASvF,QAAQ,GAAGA,QAAQoF,MAAMnF,QAAQ,EAAED,OAAO;AACjD,QAAIoF,MAAMpF,WAAWuF,OAAO;AAC1B,aAAOvF,QAAQ;IAChB;EACF;AAED,SAAO;AACR;AAUD,SAAS6G,mBACPtB,OACAE,OACA1B,OACA+C,WACA;AACA,MAAI,CAACA,WAAW;AACd,QAAMlC,OAAO,OAAOW;AAEpB,QAAIxD,eAAe6C,OAAsC;AACvD,aAAUA,OAAV,MAAkBW;IACnB;AAED,QAAIA,UAAU,MAAM;AAClB,aAAUA,QAAV,MAAmBA;IACpB;EACF;AAED,MAAMwB,MAAMD,aAAcrD,SAASuD,KAAKzB,KAAd;AAE1B,MAAIvD,UAAU+E,MAAgC;AAC5C,WAAOxB;EACR;AAED,MAAIwB,QAAQ7F,kBAAkB2C,QAAQ;AACpC,WAAOsC,gBAAgBZ,KAAD;EACvB;AAED,MAAIpD,eAAe4E,MAAqC;AACtD,WAAU5F,aAAa4F,OAAvB,MAA+BxB,MAAM9B,SAAN;EAChC;AAED,MAAIhC,cAAcsF,MAAoC;AACpD,WAAOxB,iBAAiB7D,MACpB8D,aAAaD,OAAOE,OAAgB1B,KAAxB,IACZkC,aAAaV,OAAOE,OAAc1B,KAAtB;EACjB;AAED,MAAIgD,QAAQ7F,kBAAkBW,MAAM;AAClC,WAAUV,aAAa4F,OAAvB,MAA+BxB,MAAM0B,QAAN;EAChC;AAED,MAAIF,QAAQ7F,kBAAkBgG,OAAO;AACnC,WAAU/F,aAAa4F,OAAvB,MAA+BxB,MAAM4B;EACtC;AAED,MAAIJ,QAAQ7F,kBAAkBkG,OAAO;AACnC,WAAOpD,eAAeuB,KAAD;EACtB;AAED,MAAInE,aAAa2F,MAAmC;AAClD,WAAU5F,aAAa4F,OAAvB;EACD;AAED,MAAInD,mBAAmByD,KAAKN,GAAxB,GAA8B;AAChC,WAAUA,IAAIO,MAAM,GAAG,EAAb,IAAV,MAA8B/B,MAAMoB;EACrC;AAED,MAAII,QAAQ7F,kBAAkBqG,kBAAkB;AAC9C,WAAUpG,aAAa4F,OAAvB,MAA+BR,+BAA+BhB,KAAD;EAC9D;AAED,MAAIlD,iBAAiB0E,MAAuC;AAC1D,WAAU5F,aAAa4F,OAAvB,MAA+BxB,MAAMS,KAAK,GAAX;EAChC;AAED,MAAIe,QAAQ7F,kBAAkBsG,aAAa;AACzC,WAAUrG,aAAa4F,OAAvB,MAA+BpD,0BAA0B4B,KAAD;EACzD;AAED,MAAIwB,QAAQ7F,kBAAkBuG,UAAU;AACtC,WAAUtG,aAAa4F,OAAvB,MAA+BpD,0BAA0B4B,MAAMnC,MAAP;EACzD;AAED,SAAOmC;AACR;AAQD,SAASmC,eAAejC,OAAmB1B,OAAqB;AAAA,MAAxC0B,UAAwC,QAAA;AAAxCA,YAAe,CAAA;EAAyB;AAAA,MAArB1B,UAAqB,QAAA;AAArBA,IAAAA,QAAiB,CAAA;EAAI;AAC9D,SAAO,SAAqB6B,KAAaL,OAAY;AACnD,QAAI,OAAOA,UAAU,UAAU;AAC7B,UAAIE,MAAMxF,QAAQ;AAChB,YAAM0H,aAAaf,eAAenB,OAAO,IAAR;AAEjC,YAAIkC,eAAe,GAAG;AACpBlC,gBAAMI,KAAK,IAAX;QACD,OAAM;AACLJ,gBAAMmC,OAAOD,UAAb;AACA5D,UAAAA,MAAK6D,OAAOD,UAAZ;QACD;AAED5D,QAAAA,MAAK8B,KAAKD,GAAV;AAEA,YAAMiC,cAAcjB,eAAenB,OAAOF,KAAR;AAElC,YAAIsC,gBAAgB,GAAG;AACrB,iBAAA,QAAY9D,MAAKuD,MAAM,GAAGO,WAAd,EAA2B7B,KAAK,GAAhC,KAAwC,OAApD;QACD;AAEDP,cAAMI,KAAKN,KAAX;MACD,OAAM;AACLE,cAAM,KAAKF;AACXxB,QAAAA,MAAK,KAAK6B;MACX;IACF;AAED,QAAIA,OAAO,KAAKA,gBAAgB/D,MAAM;AACpC,aAAOgF,mBAAmB,KAAKjB,MAAMH,OAAO1B,OAAM7C,kBAAkBW,IAA3C;IAC1B;AAED,WAAOgF,mBAAmBtB,OAAOE,OAAO1B,KAAf;EAC1B;AACF;AAQD,SAAS+B,UAAUP,OAAYE,OAAe1B,OAAyB;AACrE,MAAI,CAACwB,SAAS,OAAOA,UAAU,UAAU;AACvC,WAAOsB,mBAAmBtB,OAAOE,OAAO1B,KAAf;EAC1B;AAED,MAAMgD,MAAMtD,SAASuD,KAAKzB,KAAd;AAEZ,MAAI3D,gBAAgBmF,MAAsC;AACxD,WAAOF,mBAAmBtB,OAAOE,OAAO1B,OAAMgD,GAArB;EAC1B;AAED,SAAOe,KAAKhC,UAAUP,OAAOmC,eAAejC,OAAO1B,KAAR,CAApC;AACR;AC3UD,SAASgE,KAAKxC,OAAY;AACxB,SAAOzF,2BAA2BgG,UAAUP,KAAD,CAAV;AAClC;AAED,SAASyC,GAAGzC,OAAY0C,YAAiB;AACvC,SAAOF,KAAKxC,KAAD,MAAYwC,KAAKE,UAAD;AAC5B;AAED,SAASC,MAAM3C,OAAmC;AAChD,WAASvF,QAAQ,GAAGA,SAAK,UAAA,UAAA,IAAA,IAAA,UAAA,SAAA,IAAuB,EAAEA,OAAO;AACvD,QAAI,CAACgI,GAAGzC,OAAmBvF,QAApB,IAAA,KAAA,UAAA,UAAoBA,QAApB,IAAA,SAAA,UAAoBA,QAApB,EAAA,GAA6B;AAClC,aAAO;IACR;EACF;AAED,SAAO;AACR;AAED,SAASmI,MAAM5C,OAAmC;AAChD,WAASvF,QAAQ,GAAGA,SAAK,UAAA,UAAA,IAAA,IAAA,UAAA,SAAA,IAAuB,EAAEA,OAAO;AACvD,QAAIgI,GAAGzC,OAAmBvF,QAApB,IAAA,KAAA,UAAA,UAAoBA,QAApB,IAAA,SAAA,UAAoBA,QAApB,EAAA,GAA6B;AACjC,aAAO;IACR;EACF;AAED,SAAO;AACR;AAED,SAASoI,MAAM7C,OAAY0C,YAAiB;AAC1C,SAAOF,KAAKxC,KAAD,MAAYwC,KAAKE,UAAD;AAC5B;AAEDD,GAAGK,MAAMH;AACTF,GAAGM,MAAMH;AACTH,GAAGO,MAAMH;AAETL,KAAKC,KAAKA;;;;AC7CiD,IAAO,kBAAQ;",
  "names": ["getUniqueIntegerFromString", "string", "index", "length", "hashA", "hashB", "charCode", "charCodeAt", "getClassTypes", "classes", "reversed", "reduce", "map", "className", "toStringClassName", "getFlags", "flags", "flag", "item", "OBJECT_CLASSES", "OBJECT_CLASS_TYPE", "OBJECT_CLASS", "BAILOUT_TAGS", "Generator", "Promise", "WeakMap", "WeakSet", "ITERABLE_TAGS", "Map", "Set", "NORMALIZED_TAGS", "Date", "RegExp", "PRIMITIVE_TAGS", "SELF_TAGS", "Arguments", "Array", "TO_STRING_TAGS", "Symbol", "TYPED_ARRAY_TAGS", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "HAS_BUFFER_FROM_SUPPORT", "Buffer", "from", "HAS_UINT16ARRAY_SUPPORT", "getStringifiedArrayBufferFallback", "buffer", "String", "fromCharCode", "apply", "getStringifiedArrayBufferModern", "toString", "getStringifiedArrayBufferNoSupport", "getStringifiedArrayBuffer", "XML_ELEMENT_REGEXP", "Object", "prototype", "keys", "getSortedEvent", "event", "bubbles", "cancelBubble", "cancelable", "composed", "currentTarget", "defaultPrevented", "eventPhase", "isTrusted", "returnValue", "target", "type", "shouldSort", "first", "second", "shouldSortPair", "firstPair", "secondPair", "sort", "array", "fn", "subIndex", "value", "getSortedMap", "cache", "entries", "forEach", "key", "push", "stringify", "entry", "join", "getSortedSet", "set", "getSortedObject", "object", "objectKeys", "newObject", "getStringifiedDocumentFragment", "fragment", "children", "innerHTML", "outerHTML", "getCutoffIndex", "getNormalizedValue", "passedTag", "tag", "call", "getTime", "Error", "stack", "Event", "test", "slice", "DocumentFragment", "ArrayBuffer", "DataView", "createReplacer", "thisCutoff", "splice", "valueCutoff", "JSON", "hash", "is", "otherValue", "isAll", "isAny", "isNot", "all", "any", "not"]
}
